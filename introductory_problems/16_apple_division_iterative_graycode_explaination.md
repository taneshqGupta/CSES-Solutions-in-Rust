## Hint
If you've seen the previous two solutions of the problem, you know that we are iterative over all possible groupings in 2^n time. We can do so using binary representation of all numbers from 0 to 2^n-1.
But recomputing the sum of every group on each new number was inefficient as you'd have to iterate over every bit that changed, luckily we can use a technique called gray code, in which only one bit changes on each iteration, and we can still iterate over all the unique numbers from 0 to 2^n-1, just in an order such that each iteration is only different from the previous one by one single changed bit. 

## Explaination
Now how to iterate on all numbers from 0 to 2^n-1 using gray code, you ask? Well there are many ways of doing so, one of which was achieved in the 13th problem gray-code by me. You can either use that recursive way of iterating on gray codes, OR you can use bitwise operations for the same, basically the formula to compute the gray code for any number "i" is gray(i) = i ^ (i >> 1). Note that this doesn't mean, 'gray(i)' and 'i' differ by one bit, it means that 'gray(i)' and 'gray(i + 1)' differ by one bit.
To understand why this formula works, (you can check it works by computing gray(6), gray(7) and gray(8)) we must understand how we go from i to i+1 in lexicographical binary ordering.
In it, the right-most zero is converted to a 1 and all the trailing one's are changed to zero.
So when we go from i -> i + 1 in normal binary ordering, what changes? the left most k digits change, k digits that were once of the form '01111' change to '1000', if 'i' had k-1 trailing zeroes, then k digits would change. Now how does this ensure gray(i) and gray(i + 1) differ by one bit?
for that we need to study what the formula 'i ^ (i >> 1)' is doing. We are going left to right in the binary and constructing the gray code also left to right, whenever we encounter a change in the binary traversal, we write one in gray code, otherwise we write zero.
Now everything comes together perfectly, because in going from i to i+1 in binary, we made k left-most bits change.
But the thing is, the first 'change' in the traversal in both happens at the k'th digit. In i, it was like 011111 and in i+1, it is like 100000.
In both cases, the first change happens at the k'th digit, But when we go from k'th digit to k+1'th digit in i+1, the story would be different.
See, if in i, the k+1'th digit was 1, i.e i was ending with 10111111, then there was a change, now i+1 ends with 11000000, making that change disappear. If there was a change at k+1'th place in i, then there would be no such change in i+1. It is easy to reason that the same is true vice versa, that if there was not a change in i(eg. 00111111) then there would be a change in i+1(01000000).
This ensures that gray(i) and gray(i+1) differ by exactly one bit. The first k bits contribute only one change at the k'th place in i to i+1. The k+1'th bit contributes either a change less or a change more. and the rest of the bits are identical in i and i+1, leading to all the same changes at all the same bits. 
And since, in the gray code formula, only the changes matter, not the bits themselves, as explored above, only one bit changes in the gray code from gray(i) to gray(i + 1). if the k+1'th bit in i was 1 (i = ..10111111) then there was a change before, and the gray(i + 1) will replace a one with zero and vice versa if k+1'th digit in original i was 0.